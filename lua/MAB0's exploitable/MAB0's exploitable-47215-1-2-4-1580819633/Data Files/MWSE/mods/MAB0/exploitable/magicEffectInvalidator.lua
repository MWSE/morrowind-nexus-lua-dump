local this = {
  modulesData = nil,
  enableEffectCollectionOnSpellTick = true,
  enableEffectInvalidationOnSpellTick = false,
  collectedEffectData = {},
  realtimeActiveEffectTrackingData = {},
  overloadedEffectReady = false
}

local function isTemporaryDuration( duration )
  return ( duration ~= 0 ) and ( duration ~= -1 )
end

local function isSpellOrPowerWithTemporaryEffect( sourceInstance, effect )
  local spell = sourceInstance.source

  if( ( spell.castType == tes3.spellType.spell ) or ( spell.castType == tes3.spellType.power ) ) then
    return isTemporaryDuration( effect.duration )
  end

  return false
end

local function isNonConstantEnchantment( sourceInstance, effect )
  local enchantment = sourceInstance.source

  if( enchantment.castType ~= tes3.enchantmentType.constant ) then
    return isTemporaryDuration( effect.duration )
  end

  return false
end

local function isCorrectAlchemyEffect( effect )
  return effect.id ~= -1
end

local function isTemporaryEffect( sourceInstance, effect )
  local sourceType = sourceInstance.sourceType

  if( sourceType == tes3.magicSourceType.spell ) then
    return isSpellOrPowerWithTemporaryEffect( sourceInstance, effect )
  elseif( sourceType == tes3.magicSourceType.enchantment ) then
    return isNonConstantEnchantment( sourceInstance, effect )
  elseif( sourceType == tes3.magicSourceType.alchemy ) then
    return isCorrectAlchemyEffect( effect )
  end

  return false
end

local function findMatchingModuleDataFromEffect( effect )
  for moduleDataIndex, moduleData in pairs( this.modulesData ) do
    if( moduleData.effectId == effect.id ) then
      if( ( moduleData.attributes == nil ) and ( moduleData.skills == nil ) ) then
        return moduleDataIndex
      elseif( ( moduleData.attributes ~= nil ) and ( moduleData.skills == nil ) ) then
        if( table.find( moduleData.attributes, effect.attribute ) ~= nil ) then
          return moduleDataIndex
        end
      elseif( ( moduleData.attributes == nil ) and ( moduleData.skills ~= nil ) ) then
        if( table.find( moduleData.skills, effect.skill ) ) then
          return moduleDataIndex
        end
      else
        if( ( table.find( moduleData.attributes, effect.attribute ) ~= nil )
            and ( table.find( moduleData.skills, effect.skill ) ~= nil ) ) then
          return moduleDataIndex
        end
      end
    end
  end
end

local function insertOrReplaceTemporaryEffectInCollectedEffectData( collectedEffect )
  local keyToAddOrReplace = collectedEffect.key

  for k, existingEffectData in pairs( this.collectedEffectData ) do
    if( ( existingEffectData.key.effectIndex == keyToAddOrReplace.effectIndex )
        and ( existingEffectData.key.serialNumber == keyToAddOrReplace.serialNumber ) ) then
      this.collectedEffectData[ k ].value = collectedEffect.value
      this.collectedEffectData[ k ].moduleDataReference = collectedEffect.moduleDataReference

      return collectedEffect
    end
  end

  table.insert( this.collectedEffectData, collectedEffect )

  return collectedEffect
end

local function makeCollectedEffectDataFromSpellTickData( spellTickData, actor, moduleDataIndex )
  return {
    key = {
      serialNumber = spellTickData.sourceInstance.serialNumber,
      effectIndex = spellTickData.effectIndex
    },
    value = {
      effectId = spellTickData.effectId,
      duration = spellTickData.sourceInstance.source.effects[ spellTickData.effectIndex + 1 ].duration,
      skill = spellTickData.sourceInstance.source.effects[ spellTickData.effectIndex + 1 ].skill + 1, -- skills are 0 indexed
      attribute = spellTickData.sourceInstance.source.effects[ spellTickData.effectIndex + 1 ].attribute + 1, -- attributes are 0 indexed
      magnitude = spellTickData.effectInstance.magnitude,
      timeActive = spellTickData.effectInstance.timeActive,
      timeInMenuMode = 0,
      [ "actor" ] = actor.mobile,
      hasBeenInvalidated = false
    },
    moduleDataReference = this.modulesData[ moduleDataIndex ]
  }
end

local function raytraceTargetedActor()
  local hitResult = tes3.rayTest( {
    position = tes3.getPlayerEyePosition(),
    direction = tes3.getPlayerEyeVector(),
    mxDistance = 200
  } )

  return hitResult and hitResult.reference
end

local function insertActorFromAllowedTarget( result, allowedTarget )
  if( allowedTarget == "player" ) then
    table.insert( result, tes3.player )
  elseif( allowedTarget == "targetedActor" ) then
    local targetedActor = raytraceTargetedActor()
    if( targetedActor ) then
      table.insert( result, targetedActor )
    end
  end
end

local function getActorsFor( moduleData )
  local result = {}

  for _, allowedTarget in pairs( moduleData.allowedTargets ) do
    insertActorFromAllowedTarget( result, allowedTarget )
  end

  return result
end

local function storeMatchingEffect( spellTickData, sourceInstance, effect )
  if( isTemporaryEffect( sourceInstance, effect  ) ) then
    local moduleDataIndex = findMatchingModuleDataFromEffect( effect )
    if( moduleDataIndex ) then
      for _, actor in pairs( getActorsFor( this.modulesData[ moduleDataIndex ] ) ) do
        if( spellTickData.target == actor ) then
          return insertOrReplaceTemporaryEffectInCollectedEffectData( makeCollectedEffectDataFromSpellTickData( spellTickData, actor, moduleDataIndex ) )
        end
      end
    end
  end
end

local function storeCollectedTemporaryEffects( spellTickData )
  local sourceInstance = spellTickData.sourceInstance
  local effects = sourceInstance.source.effects

  for _, effect in ipairs( effects ) do
    if( effect.id == spellTickData.effectId ) then
      return storeMatchingEffect( spellTickData, sourceInstance, effect )
    end
  end
end

local function pruneExpiredCollectedEffects()
  local newCollectedEffectData = {}

  for _, collectedEffect in pairs( this.collectedEffectData ) do
    if( collectedEffect.value.timeActive < collectedEffect.value.duration ) then
      table.insert( newCollectedEffectData, { key = collectedEffect.key, value = collectedEffect.value, moduleDataReference = collectedEffect.moduleDataReference } )
    end
  end

  this.collectedEffectData = newCollectedEffectData
end

local function manageOverloadedEffect( collectedEffect, spellTickData )
  if( collectedEffect and collectedEffect.moduleDataReference.overloadEffect )then
    spellTickData.block = true

    -- this code is needed as the very first spellTick firing has not a correct magnitude but the second and next have
    if( this.overloadedEffectReady == true ) then
      collectedEffect.moduleDataReference.revertEffectFade( collectedEffect )
      this.overloadedEffectReady = false
    else
      this.overloadedEffectReady = true
    end
  end
end

local function onCollectEffectsSpellTick( spellTickData )
  if( not this.enableEffectCollectionOnSpellTick ) then return end

  pruneExpiredCollectedEffects()
  manageOverloadedEffect( storeCollectedTemporaryEffects( spellTickData ), spellTickData )
end

local function haveAllCollectedEffectDataBeenInvalidated()
  for _, collectedEffect in pairs( this.collectedEffectData ) do
    if( collectedEffect.value.hasBeenInvalidated == false ) then
      return false
    end
  end

  return true
end

local function enableEffectCollectionOnSpellTick()
  this.enableEffectCollectionOnSpellTick = true
  this.enableEffectInvalidationOnSpellTick = false
end

local function clearAllCollectedData()
  this.collectedEffectData = {}
  this.realtimeActiveEffectTrackingData = {}
end

local function areSpellTickDataAndCollectedEffectMatching( spellTickData, collectedEffect )
  return ( collectedEffect.key.serialNumber == spellTickData.sourceInstance.serialNumber )
         and ( collectedEffect.key.effectIndex == spellTickData.effectIndex )
end

local function notifyEffectActiveTimeInvalidated( collectedEffect, newEffectRemainingTime, fromMenuMode )
  local metadataController = require( "MAB0.metadataController" ).getMetadataControllerByModName( "exploitable" )
  local metadata = metadataController.get()
  local eventData = {
    sourceInstanceSerialNumber = collectedEffect.key.serialNumber,
    sourceEffectIndex = collectedEffect.key.effectIndex,
    effectId = collectedEffect.value.effectId,
    newEffectRemainingTime = newEffectRemainingTime,
    fromMenuMode = fromMenuMode
  }

  event.trigger( metadataController.getEventName( metadata.events.effectActiveTimeInvalidated ), { [ "effectData" ] = eventData } )
end

local function modifyCollectedEffectTimeActive( collectedEffect, spellTickData )
  local totalEffectTimeActive = collectedEffect.value.timeActive + collectedEffect.value.timeInMenuMode

  if( collectedEffect.value.duration <= totalEffectTimeActive ) then
    spellTickData.effectInstance.timeActive = collectedEffect.value.duration
  else
    spellTickData.effectInstance.timeActive = totalEffectTimeActive
  end

  collectedEffect.value.hasBeenInvalidated = true
end

local function notifyForActiveEffectActiveTimeModification( collectedEffect, spellTickData )
  local remainingTime = collectedEffect.value.duration - spellTickData.effectInstance.timeActive
  remainingTime = ( remainingTime < 0 ) and 0 or remainingTime

  notifyEffectActiveTimeInvalidated( collectedEffect, remainingTime, false )
end

local function modifyAndNotifyForMagicEffectInstanceTimeActive( collectedEffect, spellTickData )
  modifyCollectedEffectTimeActive( collectedEffect, spellTickData )
  notifyForActiveEffectActiveTimeModification( collectedEffect, spellTickData )
end

local function modifyMagicEffectInstanceTimeActive( collectedEffect, spellTickData )
  if( collectedEffect.value.hasBeenInvalidated == true ) then return end

  if( areSpellTickDataAndCollectedEffectMatching( spellTickData, collectedEffect ) ) then
    modifyAndNotifyForMagicEffectInstanceTimeActive( collectedEffect, spellTickData )
  end
end

local function onInvalidateActiveEffectsSpellTick( spellTickData )
  if( not this.enableEffectInvalidationOnSpellTick ) then return end

  if( haveAllCollectedEffectDataBeenInvalidated() ) then
    enableEffectCollectionOnSpellTick()
    clearAllCollectedData()
  end

  for _, collectedEffect in pairs( this.collectedEffectData ) do
    modifyMagicEffectInstanceTimeActive( collectedEffect, spellTickData )
  end
end

local function areTrackingDataAndCollectedEffectMatching( trackingData, collectedEffect )
  return ( trackingData.effectKey.effectIndex == collectedEffect.key.effectIndex )
           and ( trackingData.effectKey.serialNumber == collectedEffect.key.serialNumber )
end

local function isTrackingDataExisting( collectedEffect )
  for _, trackingData in pairs( this.realtimeActiveEffectTrackingData ) do
    if( areTrackingDataAndCollectedEffectMatching( trackingData, collectedEffect ) ) then
      return true
    end
  end

  return false
end

local function getRemainingTimeForCollectedEffect( collectedEffect )
  return ( collectedEffect.value.duration - collectedEffect.value.timeActive )
end

local function applyEffectFade( collectedEffect )
  collectedEffect.moduleDataReference.applyEffectFade( collectedEffect )
end

local function updateGUI()
  tes3ui.updateEnchantingMenu()
  tes3ui.updateDialogDisposition()
  tes3ui.updateInventoryTiles()
  tes3ui.updateBarterMenuTiles()
  tes3ui.updateContentsMenuTiles()
end

local function makeTrackingEffectData( collectedEffect )
  if( isTrackingDataExisting( collectedEffect ) ) then
    return nil
  end

  local timer = timer.start( {
    duration = getRemainingTimeForCollectedEffect( collectedEffect ),
    -- time's passes even in menu mode but not when the game loses focus
    type = timer.real,
    callback = function()
      applyEffectFade( collectedEffect )
      updateGUI()
      notifyEffectActiveTimeInvalidated( collectedEffect, 0, true )
    end
  } )

  return {
    [ "timer" ] = timer,
    [ "effectKey" ] = {
      serialNumber = collectedEffect.key.serialNumber,
      effectIndex = collectedEffect.key.effectIndex
    }
  }
end

local function createTrackingDataForCollectedEffect( collectedEffect )
  local trackingData = makeTrackingEffectData( collectedEffect )

  if( trackingData ~= nil ) then
    table.insert( this.realtimeActiveEffectTrackingData, trackingData )
  end
end

local function disableEffectCollectOnSpellTick()
  if( #this.collectedEffectData > 0 ) then
    this.enableEffectCollectionOnSpellTick = false
  end
end

local function simulateContinuousTimeForEffects()
  for _, collectedEffect in pairs( this.collectedEffectData ) do
    createTrackingDataForCollectedEffect( collectedEffect )
  end

  disableEffectCollectOnSpellTick()
end

local function onMenuEnter()
  pruneExpiredCollectedEffects()
  simulateContinuousTimeForEffects()
end

local function pauseTimer( aTimer )
  if( aTimer.state ~= timer.expired ) then
    aTimer:pause()
  end
end

local function pauseRealtimeActiveEffectTrackingTimers()
  for _, trackingData in pairs( this.realtimeActiveEffectTrackingData ) do
    pauseTimer( trackingData.timer )
  end
end

local function getTimerTimeLeft( aTimer )
  return aTimer.timeLeft and aTimer.timeLeft or 0
end

local function updateTimeInMenuModeForRelatedCollectedEffect( trackingData )
  for _, collectedEffect in pairs( this.collectedEffectData ) do
    if( areTrackingDataAndCollectedEffectMatching( trackingData, collectedEffect ) ) then
      collectedEffect.value.timeInMenuMode = trackingData.timer.duration - getTimerTimeLeft( trackingData.timer )
      return
    end
  end
end

local function updateActiveEffectsTime()
  for _, trackingData in pairs( this.realtimeActiveEffectTrackingData ) do
    updateTimeInMenuModeForRelatedCollectedEffect( trackingData )
  end
end

local function findCollectedEffectByEffectKey( effectKey )
  for _, collectedEffect in pairs( this.collectedEffectData ) do
    if( ( collectedEffect.key.serialNumber == effectKey.serialNumber )
        and ( collectedEffect.key.effectIndex == effectKey.effectIndex ) ) then
      return collectedEffect
    end
  end
end

local function isTimerExpired( aTimer )
  return aTimer.state == timer.expired
end

local function revertEffectFade()
  for _, trackingData in pairs( this.realtimeActiveEffectTrackingData ) do
    local collectedEffect = findCollectedEffectByEffectKey( trackingData.effectKey )
    if( isTimerExpired( trackingData.timer ) ) then
      if( not collectedEffect.moduleDataReference.overloadEffect ) then
        collectedEffect.moduleDataReference.revertEffectFade( collectedEffect )
      end
    end
  end
end

local function enableEffectInvalidationOnSpellTick()
  this.enableEffectCollectionOnSpellTick = false
  this.enableEffectInvalidationOnSpellTick = true
end

local function prepareCollectedEffectsInvalidation()
  pauseRealtimeActiveEffectTrackingTimers()
  updateActiveEffectsTime()
  revertEffectFade()
  enableEffectInvalidationOnSpellTick()
end

local function onMenuExit()
  if( this.enableEffectCollectionOnSpellTick ) then return end

  prepareCollectedEffectsInvalidation()
end

local function cancelTimer( aTimer )
  if( aTimer.state ~= timer.expired ) then
    aTimer:cancel()
  end
end

local function cancelRealtimeTrackingDataTimers()
  for _, trackingData in pairs( this.realtimeActiveEffectTrackingData ) do
    cancelTimer( trackingData.timer )
  end
end

local function resetModuleState()
  cancelRealtimeTrackingDataTimers()
  this.collectedEffectData = {}
  this.realtimeActiveEffectTrackingData = {}
end

local function assertModuleDataPropertiesCorrectness( data, printMessage )
  local hasNumberProperty = function( property ) return ( type( data[ property ] ) == "number" ) end
  local hasTableProperty = function( property ) return ( type( data[ property ] ) == "table" ) end
  local hasOptionalNonEmptyTableProperty = function( property ) return ( ( data[ property ] == nil ) or ( type( data[ property ] ) == "table" ) and ( #data[  property] > 0 ) ) end
  local allowedTargetsContainsOnly = function( elts ) for _, v in pairs( data.allowedTargets ) do if( table.find( elts, v ) == nil ) then return false end end return true end

  local _
  _ = hasNumberProperty( "effectId" ) or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData.effectId' must exist as a number." ) )
  _ = hasTableProperty( "allowedTargets" ) or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData.allowedTargets' must exist as a table." ) )
  _ = allowedTargetsContainsOnly( { "player", "targetedActor" } ) or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData.allowedTargets' can only contains 'player' and 'targetedActor'" ) )
  _ = hasOptionalNonEmptyTableProperty( "skills" ) or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData.skills' must be an optional non empty table." ) )
  _ = hasOptionalNonEmptyTableProperty( "attributes" ) or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData.skills' must be an optional non empty table." ) )
end

local function assertModuleDataCorrectness( moduleData ) -- todo callbacks checking
  local printMessage = function()
    tes3.messageBox( "Error with exploitable initialization. Check MWSE.log." )

    return true
  end

  local isTable = function() return ( type( moduleData ) == "table" ) end
  local isNotEmpty = function() return ( #moduleData > 0 ) end

  local _
  _ = isTable() or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData' must be a table." ) )
  _ = isNotEmpty() or ( printMessage() and assert( false, "Error when initializing magicEffectInvalidator. 'moduleData' must not be an empty table." ) )

  for _, data in pairs( moduleData ) do
    assertModuleDataPropertiesCorrectness( data, printMessage )
  end
end

local function isModulesDataInitialized()
  return ( this.modulesData and ( #this.modulesData > 0 ) )
end

return {
  new = function()
    return {
      appendModuleData = function( moduleData )
        assertModuleDataCorrectness( moduleData )

        this.modulesData = this.modulesData or {}

        for _, v in pairs( moduleData ) do
          table.insert( this.modulesData, v )
        end
      end,

      start = function()
        if( not isModulesDataInitialized() ) then return end

        event.register( "spellTick", onCollectEffectsSpellTick )
        event.register( "spellTick", onInvalidateActiveEffectsSpellTick )
        event.register( "menuEnter", onMenuEnter )
        event.register( "menuExit", onMenuExit )
      end,

      stop = function()
        if( not isModulesDataInitialized() ) then return end

        resetModuleState()

        event.unregister( "spellTick", onCollectEffectsSpellTick )
        event.unregister( "spellTick", onInvalidateActiveEffectsSpellTick )
        event.unregister( "menuEnter", onMenuEnter )
        event.unregister( "menuExit", onMenuExit )
      end
    }
  end
}