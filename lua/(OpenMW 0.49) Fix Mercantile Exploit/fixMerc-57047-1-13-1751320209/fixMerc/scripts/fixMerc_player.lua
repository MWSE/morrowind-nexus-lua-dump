
local I = require('openmw.interfaces')
local types = require('openmw.types')
local self = require('openmw.self')
local Player = require('openmw.types').Player
local core = require('openmw.core')
local self = require('openmw.self')
local vanillaDB = require('scripts.fixMerc_vanillaDB')

storage = require('openmw.storage')
MODNAME = "fixMercantile"
playerSection = storage.playerSection('SettingsPlayer'..MODNAME)
local settings = require('scripts.fixMerc_settings')
-----------------
-- CONFIGURATION: (how many skill points do you get per 100g spent/gained? each skill level you need skillpoints equal to your skill level)
SKILL_POINTS_PER_100G = 1.5
BRIBE_MULTIPLIER = 3


temporary_gold_change=0
player_gold_old=nil
player_gold_old2=nil
currentMerchant=nil
lastBarterModeTime=0
goldBeforeBarter = 0
goldBeforeTrade = 0

function getGold()
	local goldItem = types.Actor.inventory(self):find('gold_001')
	return goldItem and goldItem.count or 0
end
	

I.SkillProgression.addSkillUsedHandler(function(skillid, params)

    if skillid == 'speechcraft' and params.skillGain > 0 then
		
		if player_gold_old2 - player_gold_old == 10 then
			if playerSection:get("Bribe10exp") > 0 then
				print("fixMerc: awarding "..playerSection:get("Bribe10exp").." exp for bribing "..(player_gold_old2 - player_gold_old))
				--temporary_gold_change = temporary_gold_change + 10*BRIBE_MULTIPLIER
				I.SkillProgression.skillUsed('mercantile', {skillGain=playerSection:get("Bribe10exp"), useType = 1, scale = nil})
			end
			temporary_gold_change = 0
		elseif player_gold_old2 - player_gold_old == 100 then
			if playerSection:get("Bribe100exp") > 0 then
				print("fixMerc: awarding "..playerSection:get("Bribe100exp").." exp for bribing "..(player_gold_old2 - player_gold_old))
				--temporary_gold_change = temporary_gold_change + 100*BRIBE_MULTIPLIER
				I.SkillProgression.skillUsed('mercantile', {skillGain=playerSection:get("Bribe100exp"), useType = 1, scale = nil})
			end
			temporary_gold_change = 0
		elseif player_gold_old2 - player_gold_old == 1000 then
			if playerSection:get("Dispo1000modifier") > 0 then
				print("fixMerc: awarding "..playerSection:get("Bribe1000exp").." exp for bribing "..(player_gold_old2 - player_gold_old))
				--temporary_gold_change = temporary_gold_change + 1000*BRIBE_MULTIPLIER
				I.SkillProgression.skillUsed('mercantile', {skillGain=playerSection:get("Dispo1000modifier"), useType = 1, scale = nil})
			end
			temporary_gold_change = 0
		end
    end
end)

local function onFrame(dt)
	if I.UI.getMode() then

	--if currentMerchant then
	--	if not I.UI.getMode() then
	--		currentMerchant = nil
	--		return
	--	end
		--for detecting bribe
		
		player_gold_old2 = player_gold_old
		local goldItem = types.Actor.inventory(self):find('gold_001')
		local goldAmount = goldItem and goldItem.count or 0
		--gold changes after barter mode is closed
		local now = core.getRealTime()
		if I.UI.getMode() == "Barter" then
			lastBarterModeTime = now
		end
		if not player_gold_old then
			player_gold_old = goldAmount
		elseif goldAmount ~= player_gold_old then
			if now - lastBarterModeTime < 0.1 then
				temporary_gold_change = temporary_gold_change + math.abs(goldAmount - player_gold_old)
			end
			player_gold_old = goldAmount
		end
	end
end

--local function FixMerc_NPCActivated (npc)
--	if npc.recordId ~= "scamp_creeper" and npc.recordId ~= "mudcrab_unique" then
--		currentMerchant = npc
--	end
--
--end

function getFatigueTerm(actor)
		max = types.Actor.stats.dynamic.fatigue(actor).base --float max = getFatigue().getModified();
        current = types.Actor.stats.dynamic.fatigue(actor).current --float current = getFatigue().getCurrent();

       normalised = max == 0 and 1 or math.max(0, current / max) --float normalised = std::floor(max) == 0 ? 1 : std::max(0.0f, current / max);
       fFatigueBase = core.getGMST("fFatigueBase") --static const float fFatigueBase = gmst.find("fFatigueBase")->mValue.getFloat();
       fFatigueMult = core.getGMST("fFatigueMult") --static const float fFatigueMult = gmst.find("fFatigueMult")->mValue.getFloat();

        return fFatigueBase - fFatigueMult * (1 - normalised)
end

function getBarterOffer(npc, mercantile, personality, luck)

		clampedDisposition = 100 --getDerivedDisposition(ptr);
        a =  math.min(100, Player.stats.skills.mercantile(self).modified) --std::min(playerPtr.getClass().getSkill(playerPtr, ESM::Skill::Mercantile), 100.f);
        b =  math.min(10, 0.1*Player.stats.attributes.luck(self).modified) --std::min(0.1f * playerStats.getAttribute(ESM::Attribute::Luck).getModified(), 10.f);
        c =  math.min(10, 0.2*Player.stats.attributes.personality(self).modified) --std::min(0.2f * playerStats.getAttribute(ESM::Attribute::Personality).getModified(), 10.f);
		
        d = math.min(100, mercantile + types.NPC.stats.skills.mercantile(npc).modifier) --std::min(ptr.getClass().getSkill(ptr, ESM::Skill::Mercantile), 100.f);
        e = math.min(10, 0.1*(luck + types.NPC.stats.attributes.luck(npc).modifier)) --std::min(0.1f * sellerStats.getAttribute(ESM::Attribute::Luck).getModified(), 10.f);
        f = math.min(10, 0.2*(personality + types.NPC.stats.attributes.personality(npc).modifier)) -- std::min(0.2f * sellerStats.getAttribute(ESM::Attribute::Personality).getModified(), 10.f);
        pcTerm = (clampedDisposition - 50 + a + b + c) * getFatigueTerm(self)
        npcTerm = (d + e + f) * getFatigueTerm(npc)
        buyTerm = 0.01 * (100 - 0.5 * (pcTerm - npcTerm));
        sellTerm = 0.01 * (50 - 0.5 * (npcTerm - pcTerm));
		
        --int offerPrice = int(basePrice * (buying ? buyTerm : sellTerm));
        --return std::max(1, offerPrice);
		return buyTerm, sellTerm
end

function haggle(npc, mercantile, luck, personality, playerOffer, merchantOffer)--(const MWWorld::Ptr& player, const MWWorld::Ptr& merchant, int playerOffer, int merchantOffer)
	--// accept if merchant offer is better than player offer
	if (playerOffer <= merchantOffer) then
		return true;
	end
	--
	--// reject if npc is a creature
	--if (merchant.getType() != ESM::NPC::sRecordId)
	--{
	--	return false;
	--}
	
	--const MWWorld::Store<ESM::GameSetting>& gmst
	--	= MWBase::Environment::get().getESMStore()->get<ESM::GameSetting>();
	
	--// Is the player buying?
	local buying = (merchantOffer < 0);
	local a = math.abs(merchantOffer)
	local b = math.abs(playerOffer)
	local d = (buying) and math.floor(100 * (a - b) / a) or math.floor(100 * (b - a) / b);
	
	local clampedDisposition = 100 --int clampedDisposition = MWBase::Environment::get().getMechanicsManager()->getDerivedDisposition(merchant);
	
	--const MWMechanics::CreatureStats& merchantStats = merchant.getClass().getCreatureStats(merchant);
	--const MWMechanics::CreatureStats& playerStats = player.getClass().getCreatureStats(player);

	local a1 = Player.stats.skills.mercantile(self).modified --static_cast<float>(player.getClass().getSkill(player, ESM::Skill::Mercantile));
	local b1 = 0.1*Player.stats.attributes.luck(self).modified --0.1 * playerStats.getAttribute(ESM::Attribute::Luck).getModified();
	local c1 = 0.2*Player.stats.attributes.personality(self).modified --0.2 * playerStats.getAttribute(ESM::Attribute::Personality).getModified();
	local d1 = mercantile + types.NPC.stats.skills.mercantile(npc).modifier --static_cast<float>(merchant.getClass().getSkill(merchant, ESM::Skill::Mercantile));
	local e1 = 0.1 * (luck +  types.NPC.stats.attributes.luck(npc).modifier) --merchantStats.getAttribute(ESM::Attribute::Luck).getModified();
	local f1 = 0.2 * (personality + types.NPC.stats.attributes.personality(npc).modifier) --merchantStats.getAttribute(ESM::Attribute::Personality).getModified();
	--print("fDispositionMod",core.getGMST("fDispositionMod"))
	--print("fBargainOfferMulti",core.getGMST("fBargainOfferMulti"))
	--print("fBargainOfferBase",core.getGMST("fBargainOfferBase"))
	local dispositionTerm = core.getGMST("fDispositionMod") * (clampedDisposition - 50);
	local pcTerm = (dispositionTerm + a1 + b1 + c1) * getFatigueTerm(self) --* playerStats.getFatigueTerm();
	local npcTerm = (d1 + e1 + f1) * getFatigueTerm(npc) --* merchantStats.getFatigueTerm();
	local x = core.getGMST("fBargainOfferMulti") * d
		+ core.getGMST("fBargainOfferBase") + math.floor(pcTerm - npcTerm);
	
	--auto& prng = MWBase::Environment::get().getWorld()->getPrng();
	local roll = 80 --int roll = Misc::Rng::rollDice(100, prng) + 1;
	
	--// reject if roll fails
	--// (or if player tries to buy things and get money)
	if (roll > x or (merchantOffer < 0 and 0 < playerOffer)) then
		return false;
	end
	return true
end
--[[
	// apply skill gain on successful barter
	float skillGain = 0.f;
	int finalPrice = std::abs(playerOffer);
	int initialMerchantOffer = std::abs(merchantOffer);
	
	if (!buying && (finalPrice > initialMerchantOffer))
	{
		skillGain = std::floor(100.f * (finalPrice - initialMerchantOffer) / finalPrice);
	}
	else if (buying && (finalPrice < initialMerchantOffer))
	{
		skillGain = std::floor(100.f * (initialMerchantOffer - finalPrice) / initialMerchantOffer);
	}
	player.getClass().skillUsageSucceeded(
		player, ESM::Skill::Mercantile, ESM::Skill::Mercantile_Success, skillGain);
	
	return true;
]]--


local function preventExploit()

	local mercantile = types.NPC.stats.skills.mercantile(currentMerchant).base
	local originalMercantile = mercantile
	local personality = types.NPC.stats.attributes.personality(currentMerchant).base
	local luck = types.NPC.stats.attributes.luck(currentMerchant).base
	
	local buyOffer, sellOffer = getBarterOffer(currentMerchant, mercantile, personality, luck)
	buyOffer = buyOffer * 1000
	sellOffer = sellOffer * 1000
	local middle = (buyOffer + sellOffer) /2
	--print(buyOffer,sellOffer,middle)
	while haggle(currentMerchant, mercantile, luck, personality, middle-1, sellOffer) or haggle(currentMerchant, mercantile, luck, personality, -middle+1, -buyOffer) do
		if mercantile < 200 then
			mercantile = mercantile + 1
		elseif personality < 100 then
			personality = personality+1
		elseif luck < 100 then
			luck = luck+1
		else
			break
		end
		buyOffer, sellOffer = getBarterOffer(currentMerchant, mercantile, personality, luck)
		buyOffer = buyOffer * 1000
		sellOffer = sellOffer * 1000
		middle = (buyOffer + sellOffer) /2
		--print(mercantile, personality, luck)
	end
	if mercantile > originalMercantile then
		mercantile = mercantile + 1
		print("fixMerc: preventing exploit:")
		currentMerchant:sendEvent("FixMerc_setMercantile", mercantile)
	end
end

local function UiModeChanged(data)
	if data.arg and (data.arg.recordId == "scamp_creeper" or data.arg.recordId == "mudcrab_unique") then
		return
	end
	if data.newMode == nil and currentMerchant then
		local dbEntry = vanillaDB[currentMerchant.recordId:lower()]
		if playerSection:get("revertHardcoreChanges") and dbEntry and playerSection:get("dontRestoreSpeechcraft") then
			currentMerchant:sendEvent("FixMerc_restoreMercantile",self)
		else
			currentMerchant:sendEvent("FixMerc_bye",self)
		end
		currentMerchant = nil
	elseif not currentMerchant and data.newMode == "Dialogue" and data.arg and types.NPC.objectIsInstance(data.arg) then
		--currentMerchant:sendEvent("FixMerc_hi",{self})
		currentMerchant = data.arg
		local dbEntry = vanillaDB[currentMerchant.recordId:lower()]
		if playerSection:get("revertHardcoreChanges") and dbEntry then
			currentMerchant:sendEvent("FixMerc_setHardcoreSpeechcraft", dbEntry[1])
			currentMerchant:sendEvent("FixMerc_setHardcoreMercantile", dbEntry[2])
		end
		
	elseif currentMerchant and data.newMode == "Barter" then
		--currentMerchant:sendEvent("FixMerc_startTrade",{self})
		goldBeforeTrade = getGold()
		preventExploit()
		
	elseif currentMerchant and data.oldMode == "Barter" and data.newMode == "Dialogue" then
		--currentMerchant:sendEvent("FixMerc_endTrade",{self})
		local dbEntry = vanillaDB[currentMerchant.recordId:lower()]
		if playerSection:get("revertHardcoreChanges") and dbEntry then
			currentMerchant:sendEvent("FixMerc_setHardcoreMercantile", dbEntry[2])
		else
			currentMerchant:sendEvent("FixMerc_restoreMercantile")
		end
		if playerSection:get("TradeMult") > 0 then
			local goldDifference = math.abs(getGold()-goldBeforeTrade)
			--old:
			--local skillIncrease = math.max(0.01,(1-0.006*skillLevel)*SKILL_POINTS_PER_100G/100*temporary_gold_change)
			--new:
			if goldDifference > 0 then
				local skillIncrease = math.log(goldDifference, playerSection:get("TradeLog"))*playerSection:get("TradeMult")
				I.SkillProgression.skillUsed('mercantile', {skillGain=skillIncrease, useType = 1, scale = nil})
				print("fixMerc: awarding "..skillIncrease.." exp for trading "..goldDifference)
			end
		end
	end
end

return {
	engineHandlers = { 
		onFrame = onFrame,
	},
	eventHandlers = { 
		FixMerc_NPCActivated = FixMerc_NPCActivated,
		UiModeChanged = UiModeChanged,
	
	}
}